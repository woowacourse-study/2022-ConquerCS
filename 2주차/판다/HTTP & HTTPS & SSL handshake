# HTTPS 통신
- `HTTPS` : `HTTP` + `SSL`
- `TCP 443` 포트를 사용
- 표준 명칭은 `TLS`

## HTTP는 평문이기 때문에 도청 가능
- HTTP는 스스로를 암호화하는 기능이 없음
- TCP/IP의 구조 상, 통신 내용은 항상 노출 가능성이 있음
- 통신을 암호화하거나 / 콘텐츠만 암호화하거나 
- 이 중에서 SSL(Secure Socket Layer) 프로토콜을 조합하여 안전한 통신로를 확보한 뒤 HTTP 통신을 하는 방식을 HTTPS 라고 한다. 


## HTTP는 통신 상대를 확인하지 않기 때문에 위장 가능
- HTTP에는 통신 상대방이 누구인지 확인하는 절차가 없음
- 위장한 서버/클라이언트일 위험이 있다.
- 리퀘스트의 송신자를 확인할 수 없어서 DDoS에 취약할 수 있다.

### SSL은 상대를 확인하는 증명서를 제공
- 증명서는 신뢰할 수 있는 기관이 발행하고, 기술적으로 위조하기 어렵도록 한다.
- 통신 상대의 증명서를 확인함으로써, 의도한 통신 상대인지 확인할 수 있다.


## HTTP는 완전성을 증명할 수 없기 때문에 변조 가능
- HTTP에서는 리퀘스트/리스폰스 송신 후, 상대방이 수신할 때까지의 사이에 변조될 가능성이 있다.
- 중간자 공격에 취약할 수 있다.
- 해시값 확인 / 디지털 서명을 통해 완전성을 확인하는 방법이 있지만, 완벽하진 않다. 
- SSL은 인증/암호화/다이제스트 기능을 제공하여 완전성을 보증


## HTTPS는 SSL으로 포장된 HTTP
- HTTP는 직접 TCP와 통신
- HTTPS에서는 HTTP는 SSL과 통신하고, SSL이 TCP와 통신한다. 
- SSL은 독립적인 프로토콜로, HTTP가 아닌 다른 프로토콜과도 조합될 수 있다. 
- HTTPS는 SSL의 사용으로 인해 리소스 소모와 네트워크 부하가 크다. 
- SSL 액셀러레이터를 통해 부하를 분산시켜 완화할 수 있지만, 한계가 존재.
- 보안이 필수적인 부분에만 HTTPS 통신을 활용하고, 나머지는 HTTP 만을 사용할 수도 있다. 

## 암호화 방식
- 공통키 방식의 암호화는 암호키 교환 과정이 존재하므로, 필연적인 취약성이 있다.
- 공개키 방식의 암호화는 초기 키 교환과정이 없으므로 보안성이 높은 대신, 처리 속도가 늦고 리소스 소모가 크다. 
- 초기 암호키 교환에만 공개키 방식을 사용하고, 이후에는 이미 교환된 공통키를 사용하여 통신하는 식의 절충안이 있다.

## 신뢰성
- 공개키 자체의 신뢰성은 인증 기관을 통해 담보된다. 
- 인증 기관의 공개키의 신뢰성은 통신과정 자체에서 담보하기는 어렵기 때문에, 브라우저에 주요 인증 기관의 공개키를 아예 내장해 놓는다.
- 클라이언트도 본인을 증명하는 증명서를 이용할 수 있다 / 안전성이 매우 높지만, 비용이 들고 배포에 별도의 과정이 요구된다. 


## SSL Handshake
1. 클라이언트가 SSL 버전, 암호화 알고리즘, 키 사이즈 등의 정보가 담긴 `Client Hello` 메시지를 송신하면서 SSL 통신을 시작한다.
2. SSL 통신이 가능한 경우, 서버는 SSL 버전과 암호화 정보 등이 담긴 `Server Hello` 메시지를 응답한다. 
3. 서버가 공개키 증명서를 포함한 `Certificate` 메시지를 송신한다. 
4. 서버는 `Server Hello Done` 메시지를 송신하여 최초 SSL 네고시에이션이 종료됨을 통보한다. 
5. 클라이언트는 통신 암호화에 사용될 `Pre-Master secret`이 포함된 `Clinet Key Exchange` 메시지를 응답하는데, 이 메시지는 서버에서 받은 공개키로 암호화된다. 
6. 클라이언트는 이제부터 암호키를 사용해서 통신이 진행된다는 의미의 `Change Cipher Spec` 메시지를 송신한다.
7. 클라이언트는 `Finished` 메시지를 송신한다. 서버는 해당 메시지의 복호화 성공 여부로 네고시에이션 성공 여부를 판단한다. 
8. 서버는 `Change Cipher Spec` 메시지를 송신한다.
9. 서버는 `Finished` 메시지를 송신한다. 
10. 상호간에 `Finished` 메시지 교환이 완료되면 SSL 접속이 확립된다. 
11. HTTP 리퀘스트/리스폰스를 통해 통신한다. 
12. 클라이언트가 `close_notify` 메시지를 송신한 후, `TCP FIN` 메시지를 송신하면서 접속을 종료한다. 




