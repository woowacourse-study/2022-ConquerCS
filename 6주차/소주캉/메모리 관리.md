# 메모리 관리
## 주소 바인딩(Address Binding)
#### 무엇인가?
논리적 주소를 물리적 메모리 주소로 연결시키는 작업이다.

#### 논리적 주소
각 프로세스마다 독립 할당되며 0부터 시작한다.

#### 물리적 주소
물리적 메모리에 실제로 올라가는 취이이다. 낮은 주소 영역에는 운영체제가 올라가고, 높은 주소 영역에는 사용자 프로세스들이 올라간다.

### 시점에 따른 분류
주소 바인딩 방식은 프로그램이 적재되는 물리적 메모리의 주소가 결정되는 시기에 따라 분류 가능하다. 

#### 컴파일 타임 바인딩(Compile time binding)
물리적 메모리 주소가 프로그램을 컴파일할 때 결정된다. 

#### 로드 타임 바인딩(Load time binding)
프로그램이 실행될 때 물리적 메모리 주소가 결정된다. 

#### 실행 시간 바인딩(Execution time binding or Runtime binding)
프로그램 실행 후에도 그 프로그램이 위치한 물리적 메모리 주소가 변경될 수 있다. 이 방식에서는 CPU가 주소를 참조할 때마다 해당 데이터가 물리적 메모리의 어느 위치에 존재하는지 주소 매핑 테이블(address mapping table)을 이용해 바인딩을 점검해야 한다. 다른 방식과 달리 기준 레지스터(base register)와 한계 레지스터(limit register)를 포함한 MMU(Memory Management Unit)이라는 하드웨어 지원이이 있어야 한다. 

### MMU
#### 무엇인가?
논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치이다. 

#### 어떻게 쓰는가?
CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때 그 주소값에 **기준 레지스터**의 값을 더해 물리적 주소값을 알아낸다.

#### 한계 레지스터(Limit register)
프로세스가 자신의 주소 공간을 넘어서는 메모리 참조를 하려고 하는지 체크하는 용도로 사용한다. 
현재 CPU에서 수행 중인 프로세스의 논리적 주소의 최댓값을 담고있다. 

## 관련 개념
### 동적 로딩
프로세스 내에서 실행에 필요한 부분이 실제로 불릴 때마다 메모리에 적재하는 로딩이다. 

#### 왜 쓰나?
여러 프로그램이 동시에 메모리에 올라가서 수행되는 다중 프로그래밍 환경에서 메모리 사용 효율성을 높이기 위해 사용한다.

### 동적 연결
컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램 실행 시점까지 지연시키는 기법이다. 

#### 왜 쓰나? 
라이브러리가 실행 시점에 연결되므로 실행 파일에 라이브러리 코드가 포함되지 않아 메모리 효율을 높일 수 있다. 

### 중첩
프로세스의 주소 공간을 분할해 실제 필요한 부분만 메모리에 적재하는 기법이다. 

### 스와핑
메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역(swap area)에 일시적으로 내려놓는 기법이다. 

#### 왜 쓰는가?
메모리에 존재하는 프로세스의 수를 조절하기 위해 사용한다. 너무 많은 프로그램이 메모리에 동시에 올라오면 프로세스당 할당되는 메모리의 양이 적어져 시스템 전체의 성능이 떨어질 수 있다. 

## 물리적 메모리 할당 방식
물리적 메모리는 운영체제 상주 영역과 사용자 프로세스 영역으로 나뉜다. 할당 방식은 사용자 프로세스 상주 영역을 관리하는 방식이다. 

#### 운영체제 상주 영역
인터럽트 벡터와 함께 물리적 메모리의 낮은 주소 영역을 사용하며, 운영체제 커널이 위치한다. 

#### 사용자 프로세스 상주 영역
물리적 메모리의 높은 주소 영역을 사용하며 여러 사용자 프로세스들이 적재된다. 

### 연속 할당 방식
각각의 프로세스를 물리적 메모리의 연속적인 공간에 올린다. 

#### 고정분할 방식
물리적 메모리를 고정된 크기의 분할로 미리 나누어둔다. 

- `특징`: 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되어 있으며 수행 가능한 프로그램의 최대 크기도 제한된다. 외부조각과 내부 조각이 발생할 수 있다. 

- `외부조각(external fragmentation)`: 프로그램 크기보다 분할 크기가 작은 경우 분할이 비어도 프로그램을 적재하지 못하는 메모리 공간
- `내부조각(internal fragmentation)`: 프로그램 크기보다 분할 크기가 큰 경우 프로그램을 적재하고 남은 메모리 공간

#### 가변분할 방식
분할을 미리 나누어놓지 않은 채 프로그램이 실행되고 종료되는 순서에 따라 분할을 관리한다. 

- `특징`: 프로그램의 크기를 고려해서 메모리를 할당하고 이를 기술적으로 관리할 수 있는 기법이 필요하다. 

- `동적 메모리 할당 문제(dynamic storage allocation problem)`: 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 물리적 메로리 내 가용 공간 중 어떤 위치에 올릴 것인가 결정하는 문제
  - `최초적합(first-fit)`: 크기가 n 이상인 가용 공간 중 가장 먼저 찾아지는 곳에 프로세스 할당. 시간 효율적
  - `최적적합(best-fit)`: 크기가 n 이상인 가장 작은 가용 공간을 찾아 프로세스 할당. 공간 효율적
  - `최악적합(worst-fit)`: 가용 공간 중에서 가장 크기가 큰 곳에 프로세스 할당
  
- 외부조각 문제 해결
  - `컴팩션(compaction)`: 물리적 메모리 중에서 프로세스에 의해 사용 중인 메모리 영역을 한쪽으로 몰고 가용 공간들을 다른 한쪽으로 모아서 하나의 큰 가용 공간을 만드는 방법. 연산 비용이 크다. 
  
### 불연속 할당 방식
하나의 프로세스를 물리적 메모리의 여러 영역에 분산해 적재한다. 

#### 페이징과 세그멘테이션
[이전 글 참조](https://velog.io/@sojukang/%ED%8E%98%EC%9D%B4%EC%A7%95Paging-%EC%84%B8%EA%B7%B8%EB%A9%98%ED%85%8C%EC%9D%B4%EC%85%98Segmentation)

# 참고
[반효경, 운영체제와 정보기술의 원리](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158903589)