# Memory

## Main Memory

> CPU가 직접 접근할 수 있는 기억장치

- 주소가 할당된 일련의 바이트들로 구성
- 프로그램이 메모리에 올라와야 프로세스가 실행됨

### MMU(Memory Management Unit)

- 논리 주소 → 물리 주소 변환
  - 한정적인 메모리 공간, 사용자에게 더 많은 메모리를 제공하기 위해 가상 주소 사용
  - 실 데이터에 접근하기 위해서는 가상 주소를 변환해야 함
  - → 프로세스의 크기가 실제 용량을 초과해도 실행될 수 있음
- 메모리 보호, 캐시 관리 등 CPU의 메모리 접근에 대한 총 관리
  - CPU는 레지스터의 지시에 따라 수행할 명령어를 가져오는데, 명령어 수행 시 필요한 데이터가 메모리에 없다면 해당 데이터부터 가져와야 함

### MMU의 메모리 보호

프로세스가 독립적인 메모리 공간을 가질 수 있도록 합법적인 주소 영역 설정해주고, 잘못된 접근이 오면 trap 발생

- base 레지스터: 메모리 상의 프로세스 시작 물리 주소 저장
- limit 레지스터: 프로세스의 사이즈 저장
- → 영역 밖에서 접근 요구 할 시 trap 발생
- base와 limit 레지스터는 커널 모드에서만 수정 가능

## Cache Memory

> 주기억장치에 저장된 내용 일부를 임시 저장하는 기억장치

→ CPU에 비해 주기억장치가 느리기 때문에, 속도 격차로 인한 성능 저하 방지하기 위한 방법

### **CPU와의 상호작용**

- CPU에서 주소 전달 → 캐시 존재 여부 확인
  - 존재(Hit) → 명령어 CPU에 전송
  - 비존재(Miss) → 주기억장치 접근 → 데이터 인출, 캐시에 저장 → 명령어 CPU에 전송

### **지역성**

> 기억장치 내의 정보를 균일하게 액세스 하는 것이 아니라 한 순간에 특정 부분을 집중적으로 참조하게 되는 특성

CPU가 자주 쓸 데이터가 캐시에 들어있어야 성능이 높아짐 → 지역성의 원리 활용

- 시간 지역성: 최근에 참조된 내용은 곧 다시 참조될 확률이 높음
- 공간 지역성: 실제 프로그램이 참조된 주소와 인접한 주소의 내용이 다시 참조될 확률이 높음

### **캐싱 라인**

> 캐시에 데이터를 저장할 때, 자료구조를 활용해 접근하기 좋게 저장하는 것

자주 사용하는 데이터라 해도, 캐시에서 원하는 데이터를 찾기 힘들면 시간 낭비

캐시에 저장하는 데이터에 데이터의 메모리 주소를 함께 저장(Set 또는 Map 등 활용) → 빠르게 정보 탐색
