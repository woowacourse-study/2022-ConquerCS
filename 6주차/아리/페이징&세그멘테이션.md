# 페이징 & 세그멘테이션

## 메모리 관리 기법

- 연속 메모리 관리
    - 프로그램 전체를 메모리에 연속적으로 할당
    - 단편화 현상 발생 가능
        - 남은 메모리 공간은 충분하지만 공간이 조각조각 나뉘어있어 할당이 불가능한 상태
        - 내부 단편화
            - 고정된 파티션 크기보다 작은 메모리 공간을 차지함으로써 공간이 남아 낭비되는 현상
        - 외부 단편화
            - 빈 공간이 있지만 연속적이지않아 할당할 수 없는 현상
            - 빈 공간들을 한쪽으로 몰아 큰 공간으로 만드는 압축 기법을 활용하여 해결 가능
    - 고정 분할 기법
        - 고정된 크기의 파티션으로 분할
        - 내부 단편화 발생 가능
    - 동적 분할 기법
        - 동적인 크기의 파티션으로 분할
        - 외부 단편화 발생 가능
- 불연속 메모리 관리
    - 프로그램의 일부가 서로 다른 메모리에 할당 가능
    - page : 프로세스를 고정된 크기로 나눈 것
    - frame : page와 같은 크기의 주 기억장치 메모리 조각
    - segment : 프로세스를 크기가 아니라 논리적인 단위로 나눈것. 따라서 각 크기는 모두 다를 수 있음.
    - 단편화 현상 (Memory Fragmentation) 해결을 위해 페이징(Paging) 혹은 세그멘테이션(Segmentation) 이용하여 불연속으로 메모리 관리!
        - 페이징은 고정크기, 내부 단편화 발생 가능
        - 세그멘테이션은 가변크기, 외부 단편화 발생 가능

## 페이징 ( Paging )

- 프로세스를 고정된 크기의 페이지 단위로 나눠 적재하는 기법
- 하나의 페이지는 하나의 프레임에 할당되며 매핑 정보는 `페이지 테이블`에 저장한다.
- 하나의 프로세스를 쪼갠 페이지들은 논리주소를 통해 페이지테이블에 연속적으로 할당한다.
- CPU는 연속적으로 할당된 페이지 논리주소를 통해 해당 페이지가 할당된 물리주소를 알아낸다.
- 장점
    - 외부 단편화 문제가 해소된다
- 단점
    - 만약 프로세스가 페이지 크기의 정수배가 아니라면 내부단편화가 발생할 수 있다. 이는 페이지 크기를 작게 줄임으로써 해결할 수 있지만, 페이지 매핑 과정이 복잡해져 비효율적이다.

![paging](https://user-images.githubusercontent.com/18046394/184170833-892c52b0-50c0-425a-b27f-a2e8497919fd.png)

## 세그멘테이션 ( Segmentation )

- 프로세스를 논리적 단위로 나눈 세그먼트로 분할하여 메모리에 적재하는 기법
- base(세그먼트 시작 번호)와 limit(세그먼트 크기)를 `세그먼트 테이블`에 저장한다.
- CPU에서 해당 세그먼트의 limit를 넘는 주소가 들어오면 인터럽트를 통해 해당 프로세스를 강제로 종료시킨다.
- 장점
    - 내부 단편화 문제가 해소된다
    - 프로그램의 중요한 부분과 그렇지 않은 부분을 분리하여 저장함으로써 보호/공유 기능을 수행할 수 있다.
- 단점
    - 외부 단편화 문제가 발생할 수 있다.

![Segmentation](https://user-images.githubusercontent.com/18046394/184170855-6256f78e-a658-490e-80d9-3b8a7595dcca.png)

## 가상 메모리 페이징 / 가상 메모리 세그멘테이션

- 프로세스의 모든 페이지/세그먼트 를 로드하는 것이 아니라 필요한 부분만 로드함으로써 메모리를 효율적으로 사용할 수 있도록 한다.
- 메모리 관리가 복잡해지므로 오버헤드가 발생할 수 있다.
