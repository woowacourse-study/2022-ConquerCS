# 메모리

## 메인메모리

**CPU가 직접 접근할 수 있는 기억장치**로, 프로세스가 실행되려면 프로그램이 메모리에 올라와 있어야 한다

프로그램이 실행되려면 프로그램 코드를 메인 메모리에 적재하고, CPU가 이에 접근하여 실행되는 것인데, 프로그램 용량이 메인 메모리보다 크다면?

## 가상메모리

실제 **물리 메모리 개념**과 **사용자의 논리 메모리 개념**을 분리한 것

⇒ 가상 주소 공간(한 프로세스가 **메모리에 저장되는 논리적인 모습**을 가상 메모리에 구현한 공간)

메모리의 공간은 한정적이므로, 사용자에게 더 많은 메모리를 제공하기 위해 **가상 주소**를 사용한다 **메모리 관리 장치**(MMU, Memory Management Unit)는 **가상 주소를 이용해 실제 데이터가 담겨 있는 주소**로 변환해준다

### **왜 필요한가**

**물리 메모리의 한계**

- 프로그램 코드 전부를 물리 메모리에 올려야한다
- 그래서 메모리 용량보다 큰 프로그램은 실행시킬 수 없다
- 여러 프로그램을 메모리에 다 올리기에는 용량의 한계가 있다
- 프로그램을 교체하면서 올리자니 메모리 교체 성능 문제가 발생한다

**가상 메모리의 장점**

- 프로그램 용량이 실제 물리 메모리보다 커도 된다
- 전체 프로그램이 물리 메모리에 올라와있지 않아도 된다
- 즉, **물리 메모리 크기에 제약을 받지 않는다**
- 따라서 더 많은 프로그램을 동시에 실행 할 수 있다
    - 응답시간은 유지
    - CPU 이용률과 처리율은 증가


***⇒ 다중 프로그래밍을 실현하기 위해 물리 메모리의 제약을 보완하고 프로세스 전체를 메모리에 올리지 않고도 실행할 수 있도록 해준다***

## 주기억장치 & 보조기억장치

### 가상메모리의 구현

운영체제는 물리 메모리의 제약을 갖고 있는 주 기억장치를 보조하기 위해 디스크를 보조 기억 장치 (Paging space)로 사용한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/45dbe067-fde8-4e69-a7f2-bd93a5fc3eb7/Untitled.png)

즉, 메인 메모리(주 기억 장치)와 디스크의 페이징 스페이스(보조 기억 장치)를 묶어 하나의 메모리처럼 동작하게 하며, 이를 통해 메인 메모리의 한계를 넘는 메모리 사용을 가능하게 하는 가상 메모리를 구현한다

### **Swapping**

CPU 할당 시간이 끝난 프로세스의 메모리를 보조 기억장치로 내보내고(swap-out) 다른 프로세스의 메모를 불러오는(swap-in) 작업을 **Swap**이라고 한다 이러한 swap 작업에는 디스크 전송 시간이 들기 때문에 메모리 공간이 부족할 때 **Swapping**이 이루어진다

*이때 CPU가 직접 접근할 수 있는 메모리를 활성 가상 메모리(Active Virtual Memory), 페이징 스페이스를 비활성 가상 메모리(Inactive Virtual Memory)라고 부른다*

# 메모리 관리

다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 **주기억장치(RAM)를 동적분할하는 메모리 관리 작업**이 필요하다.

즉, 하드 디스크에 있는 프로그램을 어떻게 메인 메모리에 적재할 것인가에 대해서 생각해야 한다.

## **연속 메모리 관리**

> 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당되어야 함
>
- 고정 분할 기법 : 주기억장치가 고정된 파티션으로 분할 ⇒ **내부 단편화 발생**
- 동적 분할 기법 : 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재 ⇒ **외부 단편화 발생**)

### 단편화(Fragmentation)

기억장치의 빈 공간 또는 자료가 여러 조각으로 나뉘는 현상.

프로세스들이 메모리에 적재되고 제거되는 일이 반복 → 프로세스들이 차지하는 메모리 틈 사이에 사용하지 못할 만큼의 작은 자유 공간들이 늘어나게 됨.

- **내부단편화**

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/83b743e6-6f3b-4a6f-937b-a33525782019/Untitled.png)

    - 프로세스가 사용하는 메모리 공간에 남는 부분
    - 프로세스가 요청한 양보다 더 많은 메모리를 할당할 때 발생하며, 메모리 분할 자유 공간과 프로세스가 사용하는 공간의 크기 차이이다
- **외부단편화**

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ccbb8754-d346-40de-ab4e-a135388bf022/Untitled.png)

    - 메모리 공간 중 사용하지 못하게 되는 부분
    - 메모리 할당 및 해제의 반복으로 메모리가 중간에 존재하긴 하지만 사용하지 않는 메모리가 존재하여 총 메모리 공간은 충분하지만 실제로는 할당 불가능한 상황
    - 외부 단편화를 해결하기 위해 **압축**을 이용하여 프로세스가 사용하는 공간을 한쪽으로 몰 수 있으나, 작업 효율이 좋지는 않다.

## **불연속 메모리 관리**

> 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법
>

앞서 봤던 단편화 문제를 해결하기 위해 제시된 기법이다.

- 외부 단편화 해소 ⇒ 페이징 (고정 크기)
- 내부 단편화 해소 ⇒ 세그멘테이션(가변 크기)

## 페이징

프로세스를 일정한 크기의 페이지로 분할해서 메모리에 적재하는 방식

- **페이지** : 고정 사이즈의 가상 메모리 내 프로세스 조각
- **프레임** : 페이지 크기와 같은 주기억장치 메모리 조각

→ 하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 없애는 메모리 관리 방법

### 페이징 테이블

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dff32105-41cd-49fd-bf4d-8009f9d8e542/Untitled.png)

- 물리 메모리 : 고정 크기의 프레임(Frame)
- 가상 메모리 : 고정 크기의 페이지(Page)

→ 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 매핑되어 저장된다.

즉, 모든 프로세스는 하나의 페이징 테이블을 가지고 있으며, 이곳에는 메인 메모리에 적재되어있는 **페이지 번호와 시작 주소**가 있다. 이를 통해 하나의 프로세스를 나눈 가상 메모리 페이지들이 각각 실제 메인 메모리의 어디에 적재되는지 알 수 있다.

### 장점

- 외부 단편화 해결
    - 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고, 물리 메모리의 남는 프레임에 적절히 배치되기 때문

### 단점

- 내부 단편화 문제

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dc620754-4c6f-4b9d-a1b7-8dbd6d0dca01/Untitled.png)

  → 페이지 단위를 작게 하면 해결할 수 있지만, page mapping 과정이 복잡해져 오히려 비효율적이다


## 세그멘테이션

프로세스를 물리적 단위인 페이지가 아닌 논리적 단위인 세그먼트로 분할해서 메모리에 적재하는 방식

- **세그먼트** : 가상 메모리를 서로 크기가 다른 논리적 단위로 분할한 것
    - **페이징은 같은 단위**로 잘라서 보관한다면, **세그멘테이션은 같은 종류로** 잘라서 보관하는 것이다!

각 세그먼트는 연속적 공간에 저장되며, 크기가 가변적이기 때문에 미리 메모리를 분할할 수는 없고 메모리에 적재될 때 빈 공간을 찾는다****

### 논리적 단위란?

프로세스가 동작하려면 기본적으로 코드, 데이터, 스택, 3가지 세그먼트를 가지고 있어야 한다 코드에는 main 함수를 포함하여 다른 함수나 루틴이 있을 수 있고, 데이터에는 구조체나 배열이 있을 수 있다

이렇게 세그먼트는 **의미가 같은 논리적 내용**을 기준으로 프로그램을 분할하기 때문에 크기가 같지 않은 것이다

### 세그먼트 테이블

분할 방식을 제외하곤 페이징과 세그멘테이션이 동일하기 때문에, 매핑 테이블의 동작 방식도 동일하다

다만, 논리 주소의 앞 비트가 페이징 번호가 아닌 세그먼트 번호이다.

### 장점

- **내부 단편화 문제가 해소된다**
- **보호와 공유 기능**을 수행할 수 있다 프로그램의 중요한 부분과 안중요한 부분을 분리하여 저장할 수 있고, 같은 코드 영역은 한번에 저장할 수 있다.

### **단점**

- **외부 단편화 문제가 커진다**