## 데드락이란?

프로세스나 스레드가 자원을 얻지 못해서 다음 처리를 하지 못하는 상태

두 개 이상의 작업이 서로 상대방의 작업이 끝나기 만을 기다리고 있기 때문에 결과적으로 아무것도 완료되지 못하는 상태

### 발생하는 경우

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/557bd35f-860d-4eb4-9b54-1567b929864a/Untitled.png)

- Process1과 Process2가 각각 Resource1과 resource2가 필요한 상황
- Process1은 Resorce1을 얻음 / Process2는 Resouce2를 얻음
- 얻지 않은 다른 자원은 기다리고 있음

→ 현재 서로 원하는 자원이 상대방에 할당되어 있어서 두 프로세스는 무한정 wait 상태에 빠짐 **(데드락 발생!)**

***→ 다중 프로그래밍 환경에서 흔히 발생하는 문제***

## **데드락(DeadLock) 발생 조건**

교착 상태가 발생하려면 4가지 조건이 모두 성립되어야 한다

### **상호 배제(Mutual exclusion)**

> 자원은 한번에 한 프로세스만 사용할 수 있음
>

### **점유 대기(Hold and wait)**

> 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 함
>

### **비선점(No preemption)**

> 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음
>

### **순환 대기(Circular wait)**

> 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 함
>

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/65a01c3b-f9ae-4d3b-8d49-84492a658345/Untitled.png)

# **교착 상태 관리**

## **예방(prevention)**

> 교착 상태 발생 조건 중 하나를 제거하면서 해결한다
>

### **상호 배제 부정**

- 여러 프로세스가 공유 자원을 사용하도록 한다

### **점유 대기 부정**

- 한 프로세스가 수행되기 전에 모든 자원을 할당시키고, 자원이 점유되지 않을 때에만 다른 프로세스에서 요구할 수 있도록 한다
- 자원 과다 사용으로 인한 효율성 문제
- 프로세스가 요구하는 자원을 파악하는 데에 대한 비용
- 자원에 대한 내용을 저장 및 복원하기 위한 비용
- 기아 상태 → 무한 대기 문제

### **비선점 부정**

- 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원을 반납하도록 한다

### **순환 대기 부정**

- 자원에 고유 번호를 할당하여 순서대로 자원을 요구하도록 한다

### **단점**

- 자원 낭비가 심하다
- 비용이 많이 든다

## **회피(avoidance)**

> 교착 상태 발생 시 피해나가는 방법
>

자원이 어떻게 요청될지에 대한 추가 정보를 제공하도록 요구하여 순환 대기가 발생하지 않도록 자원 할당 상태를 검사한다

### **순환대기가 발생하는지 판단하는 방법 - 안전상태와 불안정 상태**

운영체제는 교착 상태에 빠질 수 있는 가능성이 있는 불안전 상태(unsafe state)와 그렇지 않은 안전 상태(safe state)로 상태를 나눈다 이에 따라 프로세스가 자원을 요청할 때, **안전 상태를 유지할 수 있는 요청만 수락**하고 **불안전 상태를 초래하는 요청은 거절**한다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/263a5301-9d2d-4557-82fe-452f4a20ea23/Untitled.png)

- **안전 상태**(Safe State)
    - 교착상태 일어날 가능성 X
    - 프로세스가 요구한 양 만큼 자원 할당 가능
    - 안전 순서열(safe sequence) 존재
        - 안전 순서열 → 현재 상태에서 모든 프로세스에게 결국에는 자원을 할당할 수 있게 해주는 프로세스 실행 순서
- **불안전 상태**(Unsafe State)
    - 교착상태 일어날 가능성 O
    - 프로세스가 요구한 양 만큼 자원 할당 불가능
    - 안전 순서열 존재 X

### 자원할당 그래프 알고리즘

> 각 자원 유형의 단위 자원이 하나밖에 없는 경우
>

이 알고리즘은 자원 할당 그래프를 통해 **교착 상태를 탐지하고 회피**하고자 한다

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1b6e87b7-4b3a-4512-9dd9-ff88657e5d59/Untitled.png)

- **요청 간선(Request Edge)** : 프로세스 노드 → 자원 노드 실선 프로세스가 자원을 할당 받고 싶다고 요청
- **할당 간선(Assignment Edge)** : 자원 노드 → 프로세스 노드 실선 자원은 프로세스에 할당
- **요청 가능 간선(Claim Edge)** : 프로세스 노드 → 자원 노드 점선 향후에 프로세스가 자원을 요청할 수 있음

**교착 상태 예측 방법**

1. 그래프에 사이클이 존재하는지 확인
2. 사이클이 존재할 경우, 자원 유형에 몇 개의 사례가 있는지 확인
3. 하나의 사례만 있으면 **교착 상태**, 여러 사례가 있으면 **교착 상태 가능성**이 있다고 판별

→ 사이클이 존재할 때 자원 유형이 하나 ↔ 교착 상태, 자원 유형이 한 개 이상 ← 교착 상태

**단점**

자원 요청 시, 탐지 알고리즘을 실행시키기 때문에 그에 대한 Overhead가 발생한다 → 성능에 큰 영향

### 은행원 알고리즘

> 각 자원 유형의 단위 자원이 여러 개일 경우
>

운영 체제가 **최소 하나의 프로세스에게는 자원을 줄 수 있는 상태를 항상 유지**하도록 한다. 은행이 최소한 한 명에게 대출해줄 수 있는 금액을 항상 보유하고 있어야 한다는 개념에서 나왔다

어떤 자원의 할당을 허용하는지에 관한 여부를 결정하기 전에,미리 결정된 모든 자원들의 최대 가능한 할당량을 가지고 시뮬레이션 해서 Safe state에 들 수 있는지 여부를 검사한다. 즉 대기중이 다른 프로세스들의 활동에 대한 **교착 상태 가능성을 미리 조사**하여 교착상태가 발생할 가능성이 없을 때에만 요청에 응하는 방식으로 교착 상태를 회피하게 된다.

따라서 프로세스가 자원을 요청하는 자원 요청 알고리즘과 해당 요청을 응했을 때 교착 상태가 발생할 수 있는 상태가 되는지, 즉, 안전 상태가 유지되는지 판별하는 안전 알고리즘을 이용하여 은행원 알고리즘을 구현할 수 있다.

**사용 자료구조**

- [Available] 시스템은 현재 얼만큼의 자원을 보유하고 있는가 길이가 m인 벡터로 표현하며, Available[j] = k 일 경우 자원 j를 k개 사용할 수 있다.
- [MAX] 각 프로세스는 최대 얼만큼의 자원을 요청할 수 있는가 n * m 행렬로 표현하며, Max[i, j] = k 일 경우 프로세스 i는 자원 j를 최대 k개까지 요청할 수 있다.
- [Allocation] 각 프로세스는 현재 얼만큼의 자원을 보유하고 있는가 n * m 행렬로 표현하며, Allocation[i, j] = k 일 경우 프로세스 i는 자원 j를 k개 할당 받았음을 의미한다.
- [Need] 각 프로세스에 남아 있는 자원 요구량이 얼마인가 n * m 행렬로 표현하며, Need[i, j] = k 일 경우 프로세스 i는 작업을 완료하기 위해 자원 j가 k개 더 필요하다 Need의 경우, Max - Allocation을 통해 계산할 수 있다.

**은행 알고리즘의 단점**

- 할당할 수 있는 자원의 수가 일정해야 한다
- 사용자 수가 일정해야 한다
- 항상 불안전 상태를 방지해야 하기 때문에 자원 이용도가 낮다
- 최대 자원 요구량(Max)를 미리 알아야 한다
- 프로세스들은 유한한 시간 안에 자원을 반납해야 한다

이러한 단점들 때문에 은행원 알고리즘은 굉장히 복잡하며 실제 상황에 접목시키기 어려우며, 따라서 현재 사용하는 방식은 아니다

## **탐지(Detection)**

> 자원할당 그래프로 교착상태를 탐지하고 회복한다.
*탐지 알고리즘 → 회복 알고리즘*
>

### **대기 그래프 (Wait-for Graph)**

- 각 자원 유형의 단위 자원이 하나밖에 없는 경우
- 자원 할당 그래프의 변형으로, 자원 할당 그래프에서 자원 노드를 제거하고 프로세스 간의 간선으로 나타낸 그래프이다

[https://camo.githubusercontent.com/45748962454ca259f39f1793412a5a5ef2978409f6da81ff494bf8ed66685a08/68747470733a2f2f6d626c6f677468756d622d7068696e662e707374617469632e6e65742f32303135303630355f38322f74687265655f6c65747465725f313433333438323235393834375179754d305f4a5045472f375f30395f54776f4772617068732e6a70673f747970653d7732](https://camo.githubusercontent.com/45748962454ca259f39f1793412a5a5ef2978409f6da81ff494bf8ed66685a08/68747470733a2f2f6d626c6f677468756d622d7068696e662e707374617469632e6e65742f32303135303630355f38322f74687265655f6c65747465725f313433333438323235393834375179754d305f4a5045472f375f30395f54776f4772617068732e6a70673f747970653d7732)

(a) 자원 할당 그래프에 대응하는 (b) 대기 그래프

- Pi → Rq, Rq → Pj 간선 2개 : Pi → Pj 간선

  → 프로세스 j가 보유중인 자원을 프로세스 i가 기다린다는 의미이다


### **Shoshani & Coffman 알고리즘**

- 각 자원 유형의 단위 자원이 여러 개일 경우
- 은행원 알고리즘과 동일한 자료구조를 사용한다.

### **탐지 알고리즘 사용 시의 기준**

탐지 알고리즘을 사용할 경우 아래와 같은 기준을 잡아서 해당 알고리즘을 사용할지 말지 정해야 한다.

1. DeadLock이 얼마나 자주 일어나는가?

2. DeadLock이 일어나면 대략 몇개의 스레드가 포함되는가?

자원 요청에 대해 대기를 해야할 때 탐지 알고리즘을 돌리는 방법도 있다. 하지만 자원을 요청할 때마다 탐지 알고리즘을 호출하는 것이기 때문에 많은 오버헤드가 발생한다.

혹은 지정된 시간 간격으로 돌리거나 CPU 이용률을 기준으로 돌릴 수 있다. 하지만 이러한 방법은 DeadLock을 야기한 스레드를 단번에 파악하기가 힘들다.

## **회복(Recovery)**

교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법

### **프로세스 종료 방법 (Process Termination)**

교착 상태의 프로세스를 종료시켜 자원을 회수한다

- 전체 종료 : 교착 상태의 프로세스를 모두 중지
- **부분 종료** : 교착 상태가 제거될 때 까지 하나씩 프로세스 중지

### **자원 선점 방법 (Resource Preemption)**

교착 상태 사이클이 없어질 때 까지 자원을 빼앗아 다른 프로세스에게 제공한다

- 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에게 할당 (해당 프로세스 일시정지 시킴)
- 우선 순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점

## **무시**

위 기법을 사용할 경우 성능에 큰 영향을 미칠 수 있기 때문에, 교착 상태 발생 확률이 낮은 경우에는 별다른 조치를 취하지 않는다

교착 상태는 자주 발생하지 않으므로 이 방법이 가장 비용이 적게 들며, 대부분의 운영체제에서 채택된 방식이다