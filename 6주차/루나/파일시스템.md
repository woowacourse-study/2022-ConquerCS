## 용어 정리

### File

- 컴퓨터에서 의미 있는 정보를 담은 논리적인 단위
- 비휘발성 보조기억장치(하드디스크)에 저장
- 다양한 저장장치를 file이라는 동일한 논리적 단위로 볼 수 있또록 한다.
- 종류
    - **실행 파일** : 운영체제가 메모리로 가져와 CPU를 이용해 작업하는 파일
    - **데이터 파일** : 실행파일이 작업하는데 필요한 데이터를 모아놓은 파일

### File attribute (= metadata)

- 파일 자체의 내용X 파일을 관리하기 위한 정보 O
- 파일 이름, 유형, 위치, 권한, 소유자 등등

### Directory

- 파일의 메타데이터중 일부를 보관하고 있는 특별한 파일
- 자신의 디렉토리에 속한 파일 이름 및 메타데이터 정보를 담음

## File System

- 컴퓨터에서 파일이나 자료를 쉽게 발견할 수 있도록, 유지 및 관리하는 방법
- 파일, 메타데이터, 디렉토리 정보 등을 관리

### 특징

- 커널 영역에서 동작
- 파일 CRUD 기능을 원활히 수행하기 위한 목적
- 계층적 디렉터리 구조를 가짐
- 디스크 파티션 별로 하나씩 둘 수 있음

### **역할**

- 파일 관리
- 파일의 예비(Backup)와 복구(Recovery) 등의 기능을 제공
- 보조 저장소 관리
- 파일의 정보가 손실되지 않도록 데이터 무결성을 유지****
- 사용자가 파일을 편리하게 사용할 수 있도록 파일의 논리적 상태(디렉터리)를 보여준다

### **개발 목적**

- 파일 관리를 편리하게 하기 위해서
- 하드디스크 용량 효율적 이용
- 하드디스크와 메인 메모리 속도차를 줄이기 위함
    - 하드디스크에 저장된 데이터는 HDD에서 실행되는 것이 아니라, 메인 메모리에 로드되어 사용된다.
    - 이 때, 파일 시스템이 HDD에 저장된 데이터들의 목차가 되어 데이터를 실행하려고 클릭했을 때 메인 메모리에 빠르게 로드될 수 있도록 한다.

### **구조**

- 메타 영역 : 데이터 영역에 기록된 파일의 이름, 위치, 크기, 시간정보, 삭제유무 등의 파일 정보
- 데이터 영역 : 파일의 데이터
- UNIX 파일 시스템에서 디스크는 512, 1024, 2048 바이트 등의 크기를 가지는 블록들로 구성되며,Boot Block, Super Block, I-Node Block, Data Block 4개의 영역을 가진다.

  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0570e2f4-1fec-49db-aaa7-b18b9e445e24/Untitled.png)

    - 부트 블록 : 부팅시 필요한 코드를 저장
    - 슈퍼 블록 : 전체 파일 시스템에 대한 정보를 저장
    - 데이터 블록 : 디렉터리별로 디렉터리 엔트리와 실제 파일에 대한 데이터 저장
    - i-node 블록 : 각 파일이나 디렉터리에 대한 모든 정보 저장
        - 파일 소유자의 사용자 번호(UID) 및 그룹 번호(GID), 파일크기, 파일 타입, 생성 시기, 최종 변경시기, 최근 사용 시기, 파일의 보호권한, 파일 링크수, 데이터가 저장된 블록의 시작 주소 등

## 파일 디스크립터 (File Descriptor)

> 프로세스가 파일에 접근하기 위해 거치는 것
>
- 시스템으로부터 할당 받은 파일을 대표하는 0이 아닌 정수값
- 프로세스에서 열린 파일의 목록을 관리하는 테이블의 인덱스
- 프로세스가 실행중인 파일을 열면 커널은 해당 프로세스의 FD 숫자 중 사용하지 않는 가장 작은 값을 할당함
- 그 다음 프로세스가 열려있는 파일에 접근하려할 때, FD 값을 이용해 파일을 지칭한다.

### 할당 및 접근 과정

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/29e5b385-ac90-4648-bfd3-58ffe1434e0e/Untitled.png)

- File Descriptor Table
    - 프로세스가 현재 사용중인 파일을 관리하는 테이블.
    - 프로세스마다 한개씩 가짐
    - File Table을 가리키는 포인터를 담고 있음 (이 배열의 index = fd)
- (Open) File Table
    - 프로세스에 의해 열린 파일의 읽기/쓰기 동작 지원
    - 파일이 열릴때 마다 하나씩 할당.
- i-node Table
    - 프로세스들이 사용하고 있는 i-node를 담고있는 테이블
    - File Table과 달리 여러번 열리더라도 하나만 할당됨.
- 예시

  `fd = open("fileA", O_WRONLY); 실행`

    1. 커널은 File System에서 fileA를 찾아, 해당 파일의 i-node를 가져와 VFS i-node table의 빈 공간(Entry)에 할당. 만약 fileA의 i-node가 이미 할당되어있는 경우, ref_cnt(reference counter)만 하나 증가시킴
    2. i-node 정보에 담겨있는 접근 권한을 찾아, 쓰기 권한(O_WRONLY)을 허용하는지 확인
    3. 권한이 있다면 file table의 Entry에 open_flag, file_offset, ref_cnt, VFS i-node table entry 포인터 등의 정보를 할당
    4. File descriptor table을 index 0부터 탐색해서, 빈 공간에 file table entry를 가리키는 포인터를 저장한다.
    5. 저장한 곳의 index를 반환
    6. 이후 한번 open한 데이터는 FD 통해서 접근
    7. FD 사용이 끝나면 ref_cnt-- => ref_cnt == 0 이면 file table entry 삭제
    8. file table entry 삭제 -> VFS inode 엔트리에 참조 카운트 값 감소 => 참조 카운트 값이 0이면(해당 파일 정보에 접근 중인 프로세스 수 == 0이면) VFS inode table entry 삭제

### FCB

> 파일을 관리하기 위한 metadata를 보관하는 파일제어 블록
>
- 보조기억장치에 존재하다가 파일이 오픈되면 주기억장치로 이동 → 파일시스템이 관리하며 사용자가 직접 참조 불가
- 파일마다 독립적으로 가지며 시스템마다 다른 내용을 가짐
- 파일 허가, 소유, 크기, 자료 블록의 위치 등을 포함하여 자세한 파일 정보를 가지고 있음. UFS에선 inode라고 함.

## **디렉터리와 디스크 구조**

- 파일 시스템 내부에 있으며, 디스크에 존재하는 파일에 대한 정보를 가지고 있는 테이블
- 각 파일의 위치,크기,할당방식,형태,소유자 등의 정보를 가짐

### **1단계 (단일) 디렉터리**

> 가장 간단한 구조
>

![https://noep.github.io/2016/02/23/10th-filesystem/10.5.png](https://noep.github.io/2016/02/23/10th-filesystem/10.5.png)

- 파일들은 서로 유일한 이름을 가짐. 서로 다른 사용자라도 같은 이름 사용 불가
- 다수의 사용자가 사용하거나, 파일 수가 증가할 때 관리가 어려움.

### 2**단계 디렉터리**

> 사용자에게 개별적인 디렉터리 만들어줌
>

![https://noep.github.io/2016/02/23/10th-filesystem/10.6.png](https://noep.github.io/2016/02/23/10th-filesystem/10.6.png)

- 중앙에 **마스터 파일 디렉터리(MFD : Master File Directory)** 가 있고, 그 아래에 **각 사용자에게 할당하는 디렉터리(UFD : User File Directory)** 가 있는 구조
    - UFD : 자신만의 사용자 파일 디렉터리
    - MFD : 사용자의 이름과 계정번호로 색인되어 있는 디렉터리
- 각 사용자별 디렉토리는 독립적
    - 다른 사용자와 같은 이름의 파일 소지 가능
    - 파일 공유가 되지 않음.


### **트리 구조 디렉터리**

> 2단계 구조 확장된 다단계 트리 구조
>

![https://noep.github.io/2016/02/23/10th-filesystem/10.7.png](https://noep.github.io/2016/02/23/10th-filesystem/10.7.png)

- 하나의 루트 디렉터리와 다수의 서브 디렉터리로 구성
- 한 비트를 활용하여, 일반 파일(0)인지 디렉터리 파일(1) 구분
- 파일 및 디렉터리 탐색은 **절대경로 혹은 상대경로**를 이용
    - **절대경로** : 루트 디렉터리를 기준으로 해당 파일 혹은 종속 디렉터리에 이르는 경로
    - **상대경로** : 현재 디렉터리를 기준으로 해당 파일 혹은 디렉터리까지 경로
- Windows, Unix 운영체제에서 사용하는 구조

### 비순환그래프 디렉토리

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b92bdbfa-5e57-4a9d-9db6-e2a3656dac4c/Untitled.png)

> 하위 파일 또는 하위 디렉터리를 공동으로 사용할 수 있으며, 사이클이 허용되지 않는 구조
>
- 하나의 파일이나 디렉터리가 여러 개의 경로 이름을 가질 수 있음
- 디렉터리 구조가 복잡하고, 공유된 하나의 파일을 탐색할 경우 다른 경로로 두 번 이상 찾아갈 수 있으므로 시스템 성능이 저하될 수 있음

### **그래프 구조 디렉터리**

> 순환이 발생하지 않도록 하위 디렉터리가 아닌 파일에 대한 링크만 허용하거나, 가비지 컬렉션을 이용해 전체 파일 시스템을 순회하고 접근 가능한 모든 것을 표시
>

![https://noep.github.io/2016/02/23/10th-filesystem/10.9.png](https://noep.github.io/2016/02/23/10th-filesystem/10.9.png)

- 링크가 있으면 우회하여 순환을 피할 수 있음
- 제거된 파일의 디스크 공간 확보를 위해 쓰레기 수집 필요****

## 파일 할당 방법

### 이유

- 하드 디스크는 Block 단위로 읽고 쓰기를 진행
- 파일에 Block을 할당할 때 free block이 생김. Block 안의 크기를 다 못 채우고 파일이 저장되는 것으로, Block에서 남는 공간이 발생하게 됨( 내부 단편화와 비슷한 현상. 공간이 낭비되므로 효율이 안 좋게 된다)
- 그렇다고 해서 Block의 크기를 줄이게 되면 디스크에서 읽고 쓰는 과정이 매우 오래 걸리게 되고, 하나의 파일을 읽는데 더 많은 Block을 읽어야하기 때문에 속도가 떨어지게 된다. 따라서 어떻게 하면 free block을 잘 할당할 것인지, 속도를 감소시키지 않게 할 것인지를 따지면서 파일을 할당하는 것이 중요하다.
- 파일 할당에는 **연속할당,연결할당,색인할당** 방법이 있다.

### **연속할당**

![https://user-images.githubusercontent.com/48278519/145119446-4fabcdb6-1c4b-4a9e-aaa8-e8789f3a3d4c.JPG](https://user-images.githubusercontent.com/48278519/145119446-4fabcdb6-1c4b-4a9e-aaa8-e8789f3a3d4c.JPG)

- **각 파일에 대해 디스크 상의 연속된 블록을 할당하는 방법**
- HDD에 Block들이 나열되어 있는데 여기에 연속된 순서대로 파일을 저장
- **장점** : 논리적으로 연속된 레코드들이 물리적으로 인접하게 저장되므로, 엑세스 시간 감소
- **단점**
    - 특정 파일을 삭제하면 중간에 Hole이 생성됨. 즉, 컴퓨터 시스템이 외부단편화가 발생
    - 파일 크기에 맞는 기억공간이 확보되지 않으면 그 파일은 생성되지 못함
    - 연속된 형태이기 때문에 중간에 크기를 증가 시키기 어려움.
    - 공간 확보를 위해 재배치를 이용한 주기적인 압축이 필요

### **연결 할당(Linked Allocation)**

![https://user-images.githubusercontent.com/48278519/145120355-d2b7b914-d87f-42cb-a3f6-a03f8caee184.JPG](https://user-images.githubusercontent.com/48278519/145120355-d2b7b914-d87f-42cb-a3f6-a03f8caee184.JPG)

- **파일을 linked list의 형태로 저장 하는 방법**
- 파일의 디스크 블록들이 디스크 내에 흩어져 있고, 디렉토리는 파일의 첫번쨰와 마지막 블록에 대한 포인터를 가짐.
- 디렉토리는 제일 처음 저장되는 block을 가리키게 되고 각 block은 포인터를 저장을 위한 4바이트 이상을 가지고 있어서 다음 block을 지칭
- **장점**
    - 외부 단편화가 없음.(임의의 자리에 넣고 포인터로 연결만 하면 되기 때문에 딱 block에 맞는 사이즈만 맞추어 넣으면 되기 때문)
    - 파일의 크기가 미리 고정될 필요가 없으며 파일은 계속해서 커질 수 있음
- **단점**
    - 포인터를 관리하기 위한 추가 공간이 필요
    - 포인터를 잃어버리거나 잘못된 포인터 주소를 가질 경우 모든 자료를 잃음
    - 포인터를 따라가는 과정을 거쳐야 하므로 속도가 느림

### **연결 할당 방법의 개선법 : 파일 할당 테이블(FAT, File Allocation Table) 사용**

![https://user-images.githubusercontent.com/48278519/145120596-232a67a6-6f28-480d-9de0-689a37846ad9.JPG](https://user-images.githubusercontent.com/48278519/145120596-232a67a6-6f28-480d-9de0-689a37846ad9.JPG)

- 파일이나 디렉토리의 위치 정보(포인터)를 저장하는 테이블
- 디스크 헤드가 FAT 정보를 읽어 임의의 블록 위치를 알아낼 수 있어 Direct Access 가능
- FAT 테이블은 각 디스크 블록마다 한 개의 항목을 가지고 있고, 이 항목은 디스크 블록 번호를 index로 찾는다.

### **색인 할당(Indexed Allocation)**

![https://user-images.githubusercontent.com/48278519/145121022-2dbb9330-0759-4a6c-b653-f55d8d128aa3.jpg](https://user-images.githubusercontent.com/48278519/145121022-2dbb9330-0759-4a6c-b653-f55d8d128aa3.jpg)

- **파일 당 인덱스 block을 사용하여 파일을 할당하는 방법**
- 하나의 인덱스 block을 두고, 이 인덱스 block에 포인터들을 모아두어 직접 접근을 가능하게 한 방법
- 각 파일들은 디스크 블록 주소를 모아 놓은 인덱스 블록을 가지며, 인덱스 block의 i번째 항목은 파일의 i번째 block을 가리킨다. 디렉토리는 인덱스 블록의 주소를 가지고 있다.
- **장점**
    - 외부 단편화 문제 해결(연결 할당의 장점)
    - direct access & sequential acess 가능(연속 할당의 장점)
- **단점**
    - 인덱스 블록 할당에 따른 저장 공간의 손실 발생

## **접근 방법**

### **순차 접근(Sequential Access)**

> 가장 간단한 접근 방법으로, 대부분 연산은 read와 write
>

![https://noep.github.io/2016/02/23/10th-filesystem/10.1.png](https://noep.github.io/2016/02/23/10th-filesystem/10.1.png)

- 현재 위치를 가리키는 포인터에서 시스템 콜이 발생할 경우 포인터를 앞으로 보내면서 read와 write를 진행.
- 뒤로 돌아갈 땐 지정한 offset만큼 되감기를 해야 한다. (테이프 모델 기반)

### **직접 접근(Direct Access)**

> 특별한 순서없이, 빠르게 레코드를 read, write 가능
>

![https://noep.github.io/2016/02/23/10th-filesystem/10.2.png](https://noep.github.io/2016/02/23/10th-filesystem/10.2.png)

- 현재 위치를 가리키는 cp 변수만 유지하면 직접 접근 파일을 가지고 순차 파일 기능을 쉽게 구현이 가능하다.
- 무작위 파일 블록에 대한 임의 접근을 허용하므로 순서의 제약이 없음
- 대규모 정보를 접근할 때 유용하기 때문에 '데이터베이스'에 활용된다.

### **기타 접근**

> 직접 접근 파일에 기반하여 색인 구축
>

![https://noep.github.io/2016/02/23/10th-filesystem/10.3.png](https://noep.github.io/2016/02/23/10th-filesystem/10.3.png)

- 크기가 큰 파일을 입출력 탐색할 수 있게 도와주는 방법임